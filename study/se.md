SOFTWARE CRISIS
---------------
The inability of IT professionals to develope bug-free software is known as <ins><strong>
Software Crisis </strong></ins>. Sadly, "Software Crisis" is something, the IT industry faces 
everyday. <br>
In the past, some Crisis have a caused a huge economical impact and have also resulted in the 
deaths of many humans. For example -

<ol>
  <li> <ins><strong>Y2k Problem :</strong></ins> This was the most crucial problem of
    the last century and it was simply our ignorance. It stems from our practice of
    using only the last 2 digits of an year. Thus, 4-digit format like 1964 would be 
    shortened to 64. Similar thing, couldn't be done with year 2000 as date cant be 00.
    Thus, millions of dollars had to be spent on fixing a practically non-existant 
    problem</li> <br>
  <li> <ins><strong>Star Wars Program :</strong></ins> This program was for the US "Patriot 
    Missiles". They were supposed to target and destroy Iraqi Squd missiles. However, it 
    failed several times and 28 soldiers died. The review team found a software bug in the
    system clock of missiles.</li> <br>
  <li> <ins><strong>Araine-5 Space Rocket :</strong></ins> This rocket was developed with a
    cost of $7 Billion over 10 years. However, it was destroyed within 39 seconds of its 
    launch. It also destroyed 4 scientific satellites. It was caused by computer's own 
    guidance system, which tried to convert rocket's sideways velocity from 64-bit to 16-bit.
    But, the value was too large and caused an overflow error and crashed the rocket.</li> <br>
  <li> <ins><strong>Windows XP :</strong></ins> Microsoft released Windows XP on 25/10/2001 
    and on the same day company had to post 18 MB of patches for bug fixes, enhancements and
    compatibility. 2 patches for fixing critical security holes, out of which 1 patch failed.
    Microsoft still advises its users to take backup for crucial data before installing 
    patches.</li> <br>
</ol>

____

What is Software Engineering
----------------------------

It is a science whose aim is the production of quality software that is delivered on time, within
budget and that satisfies its requirements.<br>
Software has become an important part of all human industries, but their are some serious problems
regarding the cost, timeliness, maintainence ad quality of software products. <br>
<b><ins>Software Engineering</ins></b> aims to solve all these problems by producing a quality, 
maintainable software on time and within budget.

____

Software Process
---------------
The way in which we produce software is called <b><ins>Software Process.</ins></b>
<ol>
  <li> Varies from organisation to organisation </li>
  <li> Requires hiring smart & knowledgeable developers and buying the latest 
    developement tools. </li>
  <li> Should be effective so that developers can use the best technical practices
     to successfully make a software. </li>
</ol>

Difficulties in improving Software Process
------------------------------------------

<ol> 
  <li> <b><ins> Lack of Time: </ins></b> There is always a shortage of time. Developement
    schedules are unrealistic and leave very less time to do anything other than coding.
    Customers demand more softwares, with high quality in the least amount of time. </li>
  <br>
  <li> <b><ins> Lack of Knowledge: </ins></b> Most organisations don't even know the best 
    practices in the industry to develope software. Developers only read about coding and
    not about testing or quality. </li> <br>
  <li> <b><ins> Wrong Motivations: </ins></b> Many developers fail to understand the benefit 
    of a clear developement process and simply try to evade it. They are not motivated about
    meeting their commitments, improving customer satisfaction and delivering excellent 
  products. </li> <br>
  <li> <b><ins> Insufficient Commitment: </ins></b> Many times, the software process improvement
    fails, simply due to lack of commitment. This is because people fail to follow the actual
    changes. Even the management has no expectation from developers about this. There is no
  clear plan. Thus, no process improvement. </li> <br>
</ol>

________

Software Characteristics
------------------------

**Some important characteristics of a software:**

<ul>
  <li> <b><ins> No Lifetime: </ins></b> As we know, that hardware products wear out with time
    and their probability of failure increases. However, a software does not wear out with
    time. Software can become obsolete, but that is due to change in environment only.
  </li> <br>
  <li> <b><ins> Easy to Manufacture: </ins></b> Software developement is a one-time effort
    and continous maintainence. It is not hard to make 1000 copies of a software. Unlike
  hardware, it does not take raw material and cost for each single unit </li> <br>
  <li> <b><ins> Reusable Components: </ins></b> We can design standard components which 
    can be reused in various projects so we dont have to write everything from scratch.
    </li><br>
  <li> <b><ins> Flexible: </ins></b> A software can be made to do almost anything. However, 
    this "almost anything" make software difficult to plan and control. But, softwares
  can accomodate almost any kind of change. </li><br>
</ul>

_____

Types of Software
-----------------
Isme har ek ka matter khud hi likh lena, badi baat nahi hai
<ol>
  <li> System Software (e.g- Windows, Android) </li>
  <li> Real-Time Software (e.g- Weather Forecasting, Temperature Monitor) </li>
  <li> Embedded Software (e.g- Security System, Signal System) </li>
  <li> Business Software (e.g- MS Office, Accounts) </li>
  <li> Personal Software (e.g- Games, Media Player) </li>
  <li> Artificial Intelligence (e.g- Cortana, Alexa) </li>
  <li> Web Based Software (e.g- web apps) </li>
  <li> Engineeing & Scientific (e.g- To perform scientific calculations) </li>
</ol>

______

Software Myths
--------------
Some myths(बातें जो सबको सच लगती है but नहीं है) regarding Software developement:

<ul>
  <li> <b><ins> They are easy to change: </ins></b> yes, we can easily alter the source code
    but if we say that it is easy to make changes in the software, it is wrong. Making 
    changes without introducing errors is extremely difficult especially in ill-handled
  softwares</li> <br>
  <li> <b><ins> Testing removes all errors: </ins></b> Software Testing is done, to make the
    software as bug-free as possible. But, we can never find all the bugs in a simple
  software test, they can only be found with time. </li><br>
  <li> <b><ins> Reusing software makes it error-proof: </ins></b> Reusability of code is a 
    power that we desire and it creates a ceratin level of security. However, without 
    analising it and testing we cannot determine that it will not have any bugs for
  our current software. </li><br>
  <li> <b><ins> More features -> Better Software: </ins></b> The truth is the opposite, the
    best softwares are those which perform only a single task but very efficiently
  </li><br>
  <li> <b><ins> More developers -> Faster Developement: </ins></b> This might be true for
    civil and mechanical engineering but isn't true for SE becuase more people might 
    create confusion and everyone is at a different skill level. 
  </li> <br>
  <li> <b><ins> Main aim is to produce working software: </ins></b> This was true in the
    past. but now the focus of the developer community has shifted to making more 
    good quality and easily maintainable programs, rather than simply working programs
  </li> 
</ul>

_______

Role of Management in Software Developement
------------------------------------------
(ek manager coding process me kaise madad kar sakta hai)

The management of software developement is heavily dependent on 4 factors: <br>
People<br>
Product<br>
Process<br>
Project<br>

People
------
<ul>
  <li> Crucial to any software developement process is selecting the right persons
    to work on that project that have a proper training and work culture.
  </li> 
  <li> <b>Manager:</b> Having a good project manager decreases the probability of
    a software failure. It is the responsibilty of a manager to motivate, guide,
    encourage and control his team. 
  </li>
  <li> <b>Coder:</b> Competent coders make the backbone of any software project.
    Coders with insufficient skills for a project will not only lead to delay
    but also increases the probability of software failure
  </li>
</ul>

Product
-------
<ul>
  <li> A product should be the solution to all the customer's problems. </li>
  <li> Objectives and scope of work should be clearly defined to understand all the
    requirements. A manager should also discuss alternate solutions
  </li> 
  <li> Manager should select the best approach within the given constraints i.e-
    deadline, budget, available tecnhology and people. 
  </li>
  <li> Without clear requirements, it is impossible to make a product a product 
    with reasonable cost in suitable time </li>
</ul>

Process
-------
<ul>
  <li> The process in which we make software can increase or decrease the probability
    of making the perfect software. Although, process priority is after people and 
    product it still plays a critical role in success of project.  
  </li>
  <li> There are various models available nowadays to select a suitable process </li>
  <li> We can set various milestones to encourage the team and take up various 
  activities to suitably fulfill all the requirements. </li>
</ul>

Project
-------
<ul>
  <li> Manager must do a proper planning and should monitor the status of developement
    to control the complexity. </li>
  <li> Most projects come late and overrun budget. To make a successful software, manager
    must understand what can go wrong and what can go right. </li>
  <li> Proper plan should always be in place becuase software surprises(when the customer
    suddenly changes the requirements of a project) are always risky</li>
</ul>

____

Build & Fix Model
-----------------

When the developers build a software without specifications or design; a product is simply
and rapidly built. This product is reworked as many times as necessary to satisfy the 
client.

<ul> <ins> Features: </ins>
  <li> Ad-Hoc approach (habda-tabdi) </li>
  <li> No well defined requirements </li>
  <li> Simple 2-phase model- First phase to write code; Second phase to fix it(Either
      error correction or adding functionality)</li>
  <li> Works well for small projects </li>
  <li> Unsatisfactory for large projects as code becomes unmanageable </li>
  <li> Bug fixing time and complexity increases exponentially </li>
  <li> Maintainence is very difficult with no guarantee </li>
  <li> Becomes more costlier at later stages </li>
</ul>

____

Waterfall Model
---------------
This is a clear model having 5 phases. These phases always occur in order and never overlap.
It is called "waterfall" due to its diagramatic representation which is like a waterfall.
Its 5 phases are as follows

<ol>
  <li> <ul><ins><b> Requirement Analysis & Specification: </b></ins> 
        <li> The goal is to understand the exact customer requirements and document them
            properly </li>
        <li> Usually there is customer involvement in this phase</li>
        <li> We produce a large document, detailing what our software system will do 
          and how it shall do it. This document is called the SRS(Software Requirement
        Specification)</li>
       </ul> 
  </li><br>
  <li> <ul> <ins><b> Design Phase: </b></ins>
        <li> Main aim of this phase is to convert the SRS document into a structure that is
          suitable for implementation in some programming language. </li>
        <li> Overall architecture of the software is defined </li>
        <li> High level and detailed design work is performed </li>
        <li> Work of this phase is documented in a <ins>SDD(Software Design Description)</ins>
        which is a documented containing information sufficient to begin coding.</li>
      </ul>
  </li><br>
  <li> <ins><b> Implementation(Coding): </b></ins> In this phase the design is implemented.
      If SDD is complete and proper, this phase proceeds smoothly because all the required
      information would be contained in SDD
  </li><br>
  <li> <ul> <ins><b> Testing: </b></ins> 
        <li> Major activities are related to examination and modification of the code</li>
        <li> Efficient test will lead to a higher quality product, satisfied customer, 
            easier maintainence and reliable results</li>
        <li> This is a very expensive phase and takes about 1/3 of total time </li>
        <li> Initially, small modules are tested in isolation from the rest of the software
          This is known as <b> Unit Testing</b></li>
        <li> Then, the interface between various modules is tested known as <b> Integration
            Testing</b></li>
        <li> <b> System Testing </b> is of the entire system with software included. It 
        builds the confidence of customer in our product</li>
    </ul></li><br>
    <li> <ul> <ins><b> Software Maintainence: </b></ins>
          <li> It is performed after the delivery of the required software </li>
          <li> It is the phase which required most effort and is most challenging </li>
          <li> It is a very broad activity including error correction, optimisation, detection
          of obsolete features and enhancing features</li>
          <li> It is done to preserve the software for a long time(even upto 50 years) and make
          it up to date</li>
        </ul>
    </li>
</ol>

<b>Problems with this model</b>
<ul>
  <li> It is very ideal. As it is difficult to define all the requirements in the beginning
  of a project</li>
  <li> Not suitable for accomodating any change</li>
  <li> Real-World Projects are rarely sequential </li>
  <li> A Working version of the software is not seen until late developement stages</li>
  <li> Doesn't work well with large scale projects</li>
  <li> Customer interaction is only in the beginning phases </li>
</ul>

____

Iterative Enhancement Model
---------------------------

This model has the same phases as Waterfall Model but with fewer restrictions. Phases occur 
in the same order as Waterfall Model, but they may be conducted in several cycles, with a 
usable product released at the end of each product. Each cycle gives some additional 
functionality.

<ul> <b> Features</b>
  <li> It occurs in various cycles </li>
  <li> In requirement analysis phase, the customers and developers specify as much requirements
    as possible. Then, they are arranged in the order of priority</li>
  <li> Design, Coding and Testing is done based on this priorities in one or more cycles</li>
  <li> Main aim of models like waterfall and prototyping is to deliver a high-quality product;
      But this model delivers a product that satisifes only some of customer's needs after every
      cycle</li>
  <li> A product will usually have many releases but the first version can be available as early
      as within a few weeks. Whereas, waterfall model may take months or even years to give 
    first usable product</li>
</ul>

____

Rapid Application Developement(RAD) Model
-----------------------------------------

In this model, user involvement is essential from requirement phase uptil delivery. This ensures
that the user's expectations and perspective is understood before design and implementation.

This model has 4 phases:
<ul> 
  <li> <b><ins> Requirements Planning: </ins></b> Requirement may be gathred using any, of the
  elicitation techniques(like FAST, QFD, etc). Complete user involvement is essential.</li>
  <li> <b><ins> User Description: </ins></b> Joint teams of customers and developers seek to
  understand review the requirements</li>
  <li> <b><ins> Construction Phase: </ins></b> This combines the design, coding and testing 
  phases of waterfall model and release the product to customer.</li>
  <li> <b><ins> Cut Over Phase: </ins></b> Testing is accepted by customer, software is 
  installed and users are trained </li>
</ul>

<ul> <b> Drawbacks: </b>
  <li> Very time consuming, as each and every aspect is discussed with the user </li>
  <li> May not be vey effective on large scale projects </li>
  <li> Requires highly experienced and skilled developers, eho may not be easy to find</li>
</ul>

____

Evolutionary Process Model 
--------------------------

It resembles the Iterative Enchancement Model, it has the same phases as Waterfall Model
occuring in a cyclic manner. However, there is no usable product at the end of each cycle
and cycles are based catergory of requirements rather than priority.

For example, in a software using this model, we may first design its GUI and only GUI,
then file storgae system ,then database and so on, till we have a usable product.

Iterative Model would have started by creating a simplistic version of software in the 
beginning with simple graphics, database and everything else. The software would become
more and more sophisticated as more and more features are added with each cycle.

<ul> <b> Advantages: </b>
  <li> Suitable when there is no need for a minimal version quickly </li>
  <li> Best when working with newer technologies which is not well understood by the
    developers.</li>
  <li> Suitable for large and complex project that must be delivered at one time</li>
  <li> Suitable for projects with unclear requirements in the beginning </li>
</ul>

____

Prototyping Model
-----------------

This model builds on the biggest drawback of waterfall model(that a usable product is
not available until a very late stage). This model aims at creating a working prototype
of the project in beginning.

Prototype is based on major requirements only. It has low reliability, less functionality
and untested performance.

This model is used to make a correct SRS document becuase the prototype has been 
evaluated by the customer and now, SRS will be much better. This feedback removes 
developer uncertainities.

Prototype may be a usable program, but it is not suitable as a software. Its code is 
generally thrown away, but the experience gained makes the resultant system better.
Therefpre, prototype may be costly, but overall costs are lower.

<ul>
  <b> Drawbacks </b>
  <li> Not suitable when time is very less</li>
  <li> REquires extensive user participation which not always possible</li>
  <li> Might not be used as a standalone model(for example, once the SRS is clear, we
  may want to develope using waterfall model) </li>
</ul>

_____

Spiral Model
------------
Major problem with all software models are that they can't deal with uncertainity, which is 
almost always present in Software projects. Important projects failed becuase the risks were
neglected and nobody was prepared to face these risks. This Model, developed by Barry Bohem, 
recognised this "risk factor" and presented a spiral model.

Radius of this model keeps on increasing, representing cumulative(ever-increasing) costs. Each
loop along the x-axis represents one phase. Each phase split into 4 sectors:
<ol> 
	<li> <ins><b> Planning: </b></ins> Determining objectives, constraints and alternatives.
	</li>
	<li> <ins><b> Risk Analysis: </b></ins> Analyze the alternatives and identify the possible
		risks involved .</li>
	<li> <ins><b> Development: </b></ins> Product development and testing </li>
	<li> <ins><b> Assessment: </b></ins> Evaluation, done by customer </li>
</ol>

<ul> <ins><b> Advantages </b></ins>
	<li> Wide range of options, it can be used to implement good features of all other 
		models </li>
	<li> Risk analysis, reduces testing time and rectifies errors at an early development
		phase </li>
	<li> It deals easily with uncertainity</li>
</ul>

<ul> <ins><b> Drawbacks: </b></ins>
	<li> It is to complex to be utilised as a real-life development model </li>
	<li> It does not provide any processes and guidance to determine objectives, risks, 
		constraints and alternatives </li>
	<li> It provides too much flexibility, which is bad in some situations</li>
</ul>

_____

Requirements Engineering
------------------------

<ul>
	<li> It is done to produce a large document(SRS) which is written in easy language and
		contains a detailed description of what the system will do, without describing, how 
	it will do</li>
	<li> The input to requirements engineering is given by the customer. </li>
	<li> It gives an overview of existing system, alongwith broad expectations from new 
		system </li>
	<li> One of the most crucial activity in software development, because without a good 
		and easy to read SRS, developers will not know what to build, customers will not
		know what to expect and no way to check if the system built is satisfactory .</li>	
</ul>

<ol> <ins><b> Steps involved in Requirements Engineering </b></ins>
	<li> <ins><b> Requirement Elicitation: </b></ins> This is also known as gathering of
		requirements. Here, the requirements are identified with the help of customer
		and some other processes. </li>
	<li> <ins><b> Requirement Analysis: </b></ins> Analysing the requirements to identify 
		defects, omissions and confilcts, if any. </li>
	<li> <ins><b> Documentation: </b></ins> This is the end product of elicitation & analysis.
		The SRS document is very important as it will be the foundation for design. </li>
	<li> <ins><b> Requirement Review: </b></ins> We review the SRS to improve its quality.
		It is also called Requirement verification.  </li>
</ol>

____

Requirement Elicitation
-----------------------
Requirement Elicitation is the most critical, yet most difficult and error-prone aspect of software
developement. It can only succeed through an effective developer-customer communication.

The real requirements only reside in the mind of customer, hence it is the most important to figure 
out the customer's expectations and desires. This is generally done by asking questions and writing
their answers, however there is always a chance of inconsistency and misunderstanding due to 
communication gap.

**There are few Requirement Elicitation Methods**

Interviews
----------
<ul>
	<li> Objective of an interview is to understand the customre's expectations from the software</li>
	<li> Engineers should be open-minded should not have interview with pre-concevied notions about
		what the customer wants </li>
	<li> It may be open-ended or structured </li>
	<li> We may interview any one of themany stakeholders like (Managing Directors, Project Managers
		, Users of software or low-level employees) </li>
</ul>

Brainstorming
-------------
Group technique to promote positive thinking and new ideas. Its main purpose is to generate a lot
of ideas, because a long-list of requirements is better than having nothing and requirements
can always be categorised and prioritised.

This technique is becoming more and more poular nowadays. It is usually done with specialised
groups like actual users, middle level employees, stakeholders. 

A highly efficient facilitator may also be required, to handle group conflicts or bias. He/She 
can encourage group behavious and discourage individualistic behaviour.

Every idea is documented in simple language and a report is generated which can be reviewed by 
facilitator. Ideas are listed and if possible, made into requirements with priorities assigned.

Facilitated Application Specification Technique
-----------------------------------------------

Their appraoch is similar to Brainstorming but the main purpose is to reduce the expectation
gap. This approach encourages the creation of joint teams of customers and developers, who
work together to understand the expectations and propse a set of requirements.

<ul><ins><b>Guidelines for a FAST session:</b></ins>
	<li> Arrange a meeting at neutral site for developers & customers </li>
	<li> Prepare an informal agenda to promote free-flow of ideas </li>
	<li> Appoint a facilitator to control the meeting. He may be a developer or an outside 
		expert </li>
	<li> Establish rules for participation and prepare board, flipcharts, worksheets, etc </li>
</ul>

Quality Function Deployment
---------------------------
The main purpose is to translate the voice of customers into technical requirements. These 
requirements lead to creation of SRS document. 

This method gives the prime importance to customer satisfaction and the requirements are 
divided into 3 categories-
<ol>
	<li> <b><ins> Normal Requirements: </ins></b> If this category of requirements are 
		present the customer will be satisfied. They are essential to the software that
		is being developed and must not be excluded. For example- For a Student Result
		Management System we must have aggregate calculation, merit list, failure list,
		report generation, etc </li>
	<li> <b><ins> Expected Requirements: </ins></b> These requirements are implicit to
		the software. These may be so obvious that customer doesnt even mention them
		explicitly(alag se). But if they are not present, customer will be dissatisfied.
		For example- For a Student Result Management System there is protection from 
		unauthorised access, warning for wrong entry of data, time stamp, identification
		, etc </li>
	<li> <b><ins> Exciting Requirements: </ins></b> These requirements may be beyond 
		customer's expectation but will be very satisfying if they are present. For example
		- in a student result management system we may have a backup system, admin functions,
		virus protection, etc </li>
</ol>
	
This process is generally carried out after interview and/or brainstorming.

Use Case Approach
-----------------
Baad me likh dunga

____
Requirement Analysis
--------------------
We review each and every requirement and make sure it is clear and consistent with all other
requirements. Various steps of Requirement Analysis are-

<ol>
	<li> <b><ins> Draw the context diagram: </ins></b> It is a simple model that defines the 
		boundaries and interaction with external worlds. It identifies the outside entities
		which may interact with the system. </li>
	<li> <b><ins> Develope a Prototype: </ins></b> Effective way to find out what customer 
		really wants, is a prototype. We use the feedback to gain experience & understand 
		the system. <b> This is only an optional activity</b></li>
	<li> <b><ins> Model the requirements: </ins></b> It consists of describing entities in the
		system in a graphical manner and representing relationships between them. It helps
		in finding inconsistencies, if any</li>
	<li> <b><ins> Finalise the Requirements: </ins></b> After modeling, and removing 
		inconsistencies and ambiguities; we now list the final requirements in a prescribed
		format </li>
</ol>

____

Data Flow Diagram
-----------------

Baad me hi likhunga

____

Requirement Documentation
-------------------------
The requirement document is known as the Software Requirement Specifications(SRS). It is a 
specification that a particular software will perform certain functions.

A good SRS reduces the probability of customer dissatisfaction and increases the probability 
of a good software overall. 

<ul> <b><ins> Basic need of SRS </ins></b>
	<li> <b> Functionality: </b> What is the software supposed to do? </li>
	<li> <b> External Interaction: </b> How does the software interact with hardware, other
		software and people. </li>
	<li> <b> Performance: </b> What should be the speed, response time, recovery time, etc of
		various software function? </li>
	<li> <b> Attributes: </b> What are the features for portability, correctness, security, 
		maintainability, etc ? </li>
</ul>  

Characteristics of a good SRS
-----------------------------

<ol> A good SRS should be -
	<li> <b><ins> Correct: </ins></b> It is correct only if each and every requirement that
		is listed would be fulfilled by the software. No exaggerations or holdbacks. </li>
	<li> <b><ins> Unambiguous: </ins></b> Each requirement that is stated, has only one 
		interpretation. If a particular term has contextual meaning, it should be made 
		clear </li>
	<li> <b><ins> Complete: </ins></b> SRS should list all significant requirements(like design,
		functionality, performance, etc), their responses to software situations(both valid and
		invalid responses) and table, diagrams, charts(if any)</li>
	<li> <b><ins> Consistent: </ins></b> No 2 or more requirements contradict each other and 
		describe the same overall theme. They should all have a similar format also. For example, 
		One requirement says color should be blue, no other should state any other color</li>
	<li> <b><ins> Verifiable: </ins></b> It should use terms which have a process to measure 
		that particular term(verify it). Should not use words like (good, pretty well, etc) 
		because there is no parameter to measure if something is good. </li>
	<li> <b><ins> Modifiable: </ins></b> Its structure and style should be such that changes can
		be made easily without making the meaning unclear and disturbing the rest of document
	structure. </li>
</ol>

____

Yaha add karna
