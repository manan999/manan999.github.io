SOFTWARE CRISIS
---------------
The inability of IT professionals to develope bug-free software is known as <ins><strong>
Software Crisis </strong></ins>. Sadly, "Software Crisis" is something, the IT industry faces 
everyday. <br>
In the past, some Crisis have a caused a huge economical impact and have also resulted in the 
deaths of many humans. For example -

<ol>
  <li> <ins><strong>Y2k Problem :</strong></ins> This was the most crucial problem of
    the last century and it was simply our ignorance. It stems from our practice of
    using only the last 2 digits of an year. Thus, 4-digit format like 1964 would be 
    shortened to 64. Similar thing, couldn't be done with year 2000 as date cant be 00.
    Thus, millions of dollars had to be spent on fixing a practically non-existant 
    problem</li> <br>
  <li> <ins><strong>Star Wars Program :</strong></ins> This program was for the US "Patriot 
    Missiles". They were supposed to target and destroy Iraqi Squd missiles. However, it 
    failed several times and 28 soldiers died. The review team found a software bug in the
    system clock of missiles.</li> <br>
  <li> <ins><strong>Araine-5 Space Rocket :</strong></ins> This rocket was developed with a
    cost of $7 Billion over 10 years. However, it was destroyed within 39 seconds of its 
    launch. It also destroyed 4 scientific satellites. It was caused by computer's own 
    guidance system, which tried to convert rocket's sideways velocity from 64-bit to 16-bit.
    But, the value was too large and caused an overflow error and crashed the rocket.</li> <br>
  <li> <ins><strong>Windows XP :</strong></ins> Microsoft released Windows XP on 25/10/2001 
    and on the same day company had to post 18 MB of patches for bug fixes, enhancements and
    compatibility. 2 patches for fixing critical security holes, out of which 1 patch failed.
    Microsoft still advises its users to take backup for crucial data before installing 
    patches.</li> <br>
</ol>

____

What is Software Engineering
----------------------------

It is a science whose aim is the production of quality software that is delivered on time, within
budget and that satisfies its requirements.<br>
Software has become an important part of all human industries, but their are some serious problems
regarding the cost, timeliness, maintainence ad quality of software products. <br>
<b><ins>Software Engineering</ins></b> aims to solve all these problems by producing a quality, 
maintainable software on time and within budget.

____

Software Process
---------------
The way in which we produce software is called <b><ins>Software Process.</ins></b>
<ol>
  <li> Varies from organisation to organisation </li>
  <li> Requires hiring smart & knowledgeable developers and buying the latest 
    developement tools. </li>
  <li> Should be effective so that developers can use the best technical practices
     to successfully make a software. </li>
</ol>

Difficulties in improving Software Process
------------------------------------------

<ol> 
  <li> <b><ins> Lack of Time: </ins></b> There is always a shortage of time. Developement
    schedules are unrealistic and leave very less time to do anything other than coding.
    Customers demand more softwares, with high quality in the least amount of time. </li>
  <br>
  <li> <b><ins> Lack of Knowledge: </ins></b> Most organisations don't even know the best 
    practices in the industry to develope software. Developers only read about coding and
    not about testing or quality. </li> <br>
  <li> <b><ins> Wrong Motivations: </ins></b> Many developers fail to understand the benefit 
    of a clear developement process and simply try to evade it. They are not motivated about
    meeting their commitments, improving customer satisfaction and delivering excellent 
  products. </li> <br>
  <li> <b><ins> Insufficient Commitment: </ins></b> Many times, the software process improvement
    fails, simply due to lack of commitment. This is because people fail to follow the actual
    changes. Even the management has no expectation from developers about this. There is no
  clear plan. Thus, no process improvement. </li> <br>
</ol>

________

Software Characteristics
------------------------

**Some important characteristics of a software:**

<ul>
  <li> <b><ins> No Lifetime: </ins></b> As we know, that hardware products wear out with time
    and their probability of failure increases. However, a software does not wear out with
    time. Software can become obsolete, but that is due to change in environment only.
  </li> <br>
  <li> <b><ins> Easy to Manufacture: </ins></b> Software developement is a one-time effort
    and continous maintainence. It is not hard to make 1000 copies of a software. Unlike
  hardware, it does not take raw material and cost for each single unit </li> <br>
  <li> <b><ins> Reusable Components: </ins></b> We can design standard components which 
    can be reused in various projects so we dont have to write everything from scratch.
    </li><br>
  <li> <b><ins> Flexible: </ins></b> A software can be made to do almost anything. However, 
    this "almost anything" make software difficult to plan and control. But, softwares
  can accomodate almost any kind of change. </li><br>
</ul>

_____

Types of Software
-----------------
Isme har ek ka matter khud hi likh lena, badi baat nahi hai
<ol>
  <li> System Software (e.g- Windows, Android) </li>
  <li> Real-Time Software (e.g- Weather Forecasting, Temperature Monitor) </li>
  <li> Embedded Software (e.g- Security System, Signal System) </li>
  <li> Business Software (e.g- MS Office, Accounts) </li>
  <li> Personal Software (e.g- Games, Media Player) </li>
  <li> Artificial Intelligence (e.g- Cortana, Alexa) </li>
  <li> Web Based Software (e.g- web apps) </li>
  <li> Engineeing & Scientific (e.g- To perform scientific calculations) </li>
</ol>

______

Software Myths
--------------
Some myths(बातें जो सबको सच लगती है but नहीं है) regarding Software developement:

<ul>
  <li> <b><ins> They are easy to change: </ins></b> yes, we can easily alter the source code
    but if we say that it is easy to make changes in the software, it is wrong. Making 
    changes without introducing errors is extremely difficult especially in ill-handled
  softwares</li> <br>
  <li> <b><ins> Testing removes all errors: </ins></b> Software Testing is done, to make the
    software as bug-free as possible. But, we can never find all the bugs in a simple
  software test, they can only be found with time. </li><br>
  <li> <b><ins> Reusing software makes it error-proof: </ins></b> Reusability of code is a 
    power that we desire and it creates a ceratin level of security. However, without 
    analising it and testing we cannot determine that it will not have any bugs for
  our current software. </li><br>
  <li> <b><ins> More features -> Better Software: </ins></b> The truth is the opposite, the
    best softwares are those which perform only a single task but very efficiently
  </li><br>
  <li> <b><ins> More developers -> Faster Developement: </ins></b> This might be true for
    civil and mechanical engineering but isn't true for SE becuase more people might 
    create confusion and everyone is at a different skill level. 
  </li> <br>
  <li> <b><ins> Main aim is to produce working software: </ins></b> This was true in the
    past. but now the focus of the developer community has shifted to making more 
    good quality and easily maintainable programs, rather than simply working programs
  </li> 
</ul>

_______

Role of Management in Software Developement
------------------------------------------
(ek manager coding process me kaise madad kar sakta hai)

The management of software developement is heavily dependent on 4 factors: <br>
People<br>
Product<br>
Process<br>
Project<br>

People
------
<ul>
  <li> Crucial to any software developement process is selecting the right persons
    to work on that project that have a proper training and work culture.
  </li> 
  <li> <b>Manager:</b> Having a good project manager decreases the probability of
    a software failure. It is the responsibilty of a manager to motivate, guide,
    encourage and control his team. 
  </li>
  <li> <b>Coder:</b> Competent coders make the backbone of any software project.
    Coders with insufficient skills for a project will not only lead to delay
    but also increases the probability of software failure
  </li>
</ul>

Product
-------
<ul>
  <li> A product should be the solution to all the customer's problems. </li>
  <li> Objectives and scope of work should be clearly defined to understand all the
    requirements. A manager should also discuss alternate solutions
  </li> 
  <li> Manager should select the best approach within the given constraints i.e-
    deadline, budget, available tecnhology and people. 
  </li>
  <li> Without clear requirements, it is impossible to make a product a product 
    with reasonable cost in suitable time </li>
</ul>

Process
-------
<ul>
  <li> The process in which we make software can increase or decrease the probability
    of making the perfect software. Although, process priority is after people and 
    product it still plays a critical role in success of project.  
  </li>
  <li> There are various models available nowadays to select a suitable process </li>
  <li> We can set various milestones to encourage the team and take up various 
  activities to suitably fulfill all the requirements. </li>
</ul>

Project
-------
<ul>
  <li> Manager must do a proper planning and should monitor the status of developement
    to control the complexity. </li>
  <li> Most projects come late and overrun budget. To make a successful software, manager
    must understand what can go wrong and what can go right. </li>
  <li> Proper plan should always be in place becuase software surprises(when the customer
    suddenly changes the requirements of a project) are always risky</li>
</ul>

____

Build & Fix Model
-----------------

When the developers build a software without specifications or design; a product is simply
and rapidly built. This product is reworked as many times as necessary to satisfy the 
client.

<ul> <ins> Features: </ins>
  <li> Ad-Hoc approach (habda-tabdi) </li>
  <li> No well defined requirements </li>
  <li> Simple 2-phase model- First phase to write code; Second phase to fix it(Either
      error correction or adding functionality)</li>
  <li> Works well for small projects </li>
  <li> Unsatisfactory for large projects as code becomes unmanageable </li>
  <li> Bug fixing time and complexity increases exponentially </li>
  <li> Maintainence is very difficult with no guarantee </li>
  <li> Becomes more costlier at later stages </li>
</ul>

____

Waterfall Model
---------------
This is a clear model having 5 phases. These phases always occur in order and never overlap.
It is called "waterfall" due to its diagramatic representation which is like a waterfall.
Its 5 phases are as follows

<ol>
  <li> <ul><ins><b> Requirement Analysis & Specification: </b></ins> 
        <li> The goal is to understand the exact customer requirements and document them
            properly </li>
        <li> Usually there is customer involvement in this phase</li>
        <li> We produce a large document, detailing what our software system will do 
          and how it shall do it. This document is called the SRS(Software Requirement
        Specification)</li>
       </ul> 
  </li>
  <li> <ul> <ins><b> Design Phase: </b></ins>
        <li> Main aim of this phase is to convert the SRS document into a structure that is
          suitable for implementation in some programming language. </li>
        <li> Overall architecture of the software is defined </li>
        <li> High level and detailed design work is performed </li>
        <li> Work of this phase is documented in a <ins>SDD(Software Design Description)</ins>
        which is a documented containing information sufficient to begin coding.</li>
      </ul>
  </li>
  <li> <ins><b> Implementation(Coding): </b></ins> In this phase the design is implemented.
      If SDD is complete and proper, this phase proceeds smoothly because all the required
      information would be contained in SDD
  </li>
  <li> <ul> <ins><b> Testing: </b></ins> 
        <li> Major activities are related to examination and modification of the code</li>
        <li> Efficient test will lead to a higher quality product, satisfied customer, 
            easier maintainence and reliable results</li>
        <li> This is a very expensive phase and takes about 1/3 of total time </li>
        <li> Initially, small modules are tested in isolation from the rest of the software
          This is known as <b> Unit Testing</b></li>
        <li> Then, the interface between various modules is tested known as <b> Integration
            Testing</b></li>
        <li> <b> System Testing </b> is of the entire system with software included. It 
        builds the confidence of customer in our product</li>
    </ul></li>
    <li> <ul> <ins><b> Software Maintainence: </b></ins>
          <li> It is performed after the delivery of the required software </li>
          <li> It is the phase which required most effort and is most challenging </li>
          <li> It is a very broad activity including error correction, optimisation, detection
          of obsolete features and enhancing features</li>
          <li> It is done to preserve the software for a long time(even upto 50 years) and make
          it up to date</li>
        </ul>
    </li>
</ol>

Problems with this model
<ul>
  <li> It is very ideal. As it is difficult to define all the requirements in the beginning
  of a project</li>
  <li> Not suitable for accomodating any change</li>
  <li> Real-World Projects are rarely sequential </li>
  <li> A Working version of the software is not seen until late developement stages</li>
  <li> Doesn't work well with large scale projects</li>
  <li> Customer interaction is only in the beginning phases </li>
</ul>

____
